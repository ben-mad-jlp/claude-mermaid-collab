# Session: wide-bright-reef

## Session Context
**Out of Scope:** (session-wide boundaries)
**Shared Decisions:** (cross-cutting choices)

---

## Work Items

### Item 1: Test execution strategy in executing-plans
**Type:** feature
**Status:** documented
**Problem/Goal:**
When executing-plans breaks work into small tasks, each TDD cycle (RED-GREEN-REFACTOR) runs the full test suite. With small tasks, there are many TDD cycles, each running ALL tests even when only one module is being changed. This is wasteful and slow.

**Approach:**
1. Each task in the dependency graph specifies which tests to run during TDD cycles via a new `tests` field (e.g., `tests: ['src/auth/*.test.ts']`)
2. During TDD within a task, only run the specified tests
3. After each wave of parallel tasks completes, run the full test suite as a checkpoint
4. This balances fast iteration (targeted tests) with correctness verification (full suite at boundaries)
5. The `tests` field is auto-generated by rough-draft skeleton phase based on the task's `files` field (convention: `foo.ts` → `foo.test.ts` or `__tests__/foo.test.ts`)

**Success Criteria:**
- Tasks in dependency graph have `tests` field populated
- TDD cycles run only specified tests (not full suite)
- Full suite runs after each wave completes
- No regression in test coverage (same tests run, just grouped differently)

**Decisions:**
- Test pattern convention: derive from file path (`src/foo/bar.ts` → `src/foo/bar.test.ts` or `src/foo/__tests__/bar.test.ts`)
- Wave = parallel batch of tasks with all dependencies satisfied

---

### Item 2: Collab compaction handling
**Type:** feature
**Status:** documented
**Problem/Goal:**
When context compaction happens during collab sessions, conversation context is lost (pending questions, partial answers, in-progress decisions) even though design.md and collab-state.json persist. This breaks the workflow flow and requires manual recovery.

**Approach:**
1. Create a `collab-compact` skill that:
   - Saves current conversation state to a "context snapshot" file
   - Triggers compaction (or waits for it)
   - On resume, reads the snapshot and continues where it left off
2. Auto-compact at major phase transitions:
   - brainstorming → rough-draft
   - rough-draft → executing-plans
3. Monitor context usage during phases and proactively compact when approaching limits
4. Context snapshot captures:
   - Current skill name and step (e.g., "brainstorming/CLARIFYING")
   - Pending question being asked to user
   - Any in-progress item being discussed
   - Last 2-3 unanswered questions or uncommitted decisions
5. Use Claude Code's `PreCompact` hook:
   - Hook fires at ~95% context capacity, just before compaction starts
   - Hook command saves current context snapshot to `.collab/<session>/context-snapshot.json`
   - On resume (via collab skill), check for snapshot and restore context
6. Auto-compact at phase transitions:
   - After brainstorming completes → save snapshot, trigger `/compact`, fresh start for rough-draft
   - After rough-draft completes → save snapshot, trigger `/compact`, fresh start for executing-plans

**Success Criteria:**
- Collab workflow can survive compaction without losing place
- Resume after compaction picks up where it left off
- Phase transitions trigger clean compaction (fresh context for new phase)
- No manual intervention needed to recover from compaction

**Decisions:**
- Skills update snapshot continuously (after user answers, decisions, phase transitions) because only skills have access to conversation context
- PreCompact hook's role is minimal (logging/backup) - real context saving is done by skills during operation
- Snapshot file: `.collab/<session>/context-snapshot.json`
- Snapshot must include `activeSkill` field (e.g., "brainstorming", "rough-draft", "executing-plans")
- On resume: collab skill checks for snapshot → re-invokes the `activeSkill` → skill reads snapshot and continues
- Resume flow modification:
  1. Check for `context-snapshot.json` → if exists, use `activeSkill` + context from snapshot
  2. If no snapshot, check `collab-state.json` → route by `phase` field
  3. If no collab-state.json → session is broken, error out
  4. Each skill's startup checks for snapshot and restores conversation context
  5. Skill continues from saved state

---

## Interface Definition

### Item 1: Test Execution Strategy

#### File Structure
- `skills/rough-draft/skill.md` - MODIFY: Add `tests` field generation to skeleton phase
- `skills/executing-plans/skill.md` - MODIFY: Use `tests` field for targeted test runs
- `skills/subagent-driven-development/implementer-prompt.md` - MODIFY: Pass test patterns to implementer

#### Data Structures

**Task Dependency Graph (YAML) - Extended:**
```yaml
tasks:
  - id: <unique-identifier>
    files: [<file-path>, ...]
    description: <what this task implements>
    tests: [<test-pattern>, ...]  # NEW FIELD
    parallel: true
    depends-on: [<task-id>, ...]
```

**Test Pattern Convention:**
- Source: `src/foo/bar.ts` → Tests: `['src/foo/bar.test.ts', 'src/foo/__tests__/bar.test.ts']`
- Generated automatically from `files` field during skeleton phase

#### Function Signatures (Conceptual - these are skill instructions)

```
# rough-draft/skill.md - Skeleton Phase
generateTestPatterns(files: string[]): string[]
  # For each file, derive test file patterns

# executing-plans/skill.md - Task Execution
runTargetedTests(testPatterns: string[]): void
  # Run only specified tests during TDD

runFullSuite(): void
  # Run after wave completes
```

---

### Item 2: Collab Compaction Handling

#### File Structure
- `skills/collab-compact/skill.md` - NEW: Skill for manual compaction
- `skills/collab/skill.md` - MODIFY: Resume flow checks for snapshot
- `skills/brainstorming/skill.md` - MODIFY: Save snapshot after user answers
- `skills/rough-draft/skill.md` - MODIFY: Save snapshot after phase transitions
- `skills/executing-plans/skill.md` - MODIFY: Save snapshot after task completions

#### Data Structures

**context-snapshot.json Schema:**
```json
{
  "version": 1,
  "timestamp": "<ISO-8601>",
  "activeSkill": "brainstorming" | "rough-draft" | "executing-plans" | "...",
  "currentStep": "<step-identifier>",
  "pendingQuestion": "<question-text-or-null>",
  "inProgressItem": <item-number-or-null>,
  "recentContext": [
    { "type": "decision", "content": "<text>" },
    { "type": "answer", "content": "<text>" }
  ]
}
```

**collab-state.json - Extended:**
```json
{
  "phase": "brainstorming" | "rough-draft/*" | "implementation",
  "lastActivity": "<ISO-8601>",
  "currentItem": <number-or-null>,
  "hasSnapshot": true | false  # NEW FIELD
}
```

#### Skill Interfaces

**collab-compact/skill.md:**
```
# Inputs
- Active collab session

# Actions
1. Save current context to context-snapshot.json
2. Trigger compaction (invoke /compact command)
3. After compaction completes, conversation resumes
4. Collab skill detects snapshot and restores context

# Outputs
- context-snapshot.json written
- Compaction triggered automatically
```

**collab/skill.md - Resume Flow:**
```
# Modified Step 5: Resume Session
1. Check for context-snapshot.json
2. IF exists: read activeSkill, invoke it directly
3. IF not exists: route by phase in collab-state.json
4. IF no collab-state.json: error - session broken
```

**Snapshot Save Function (all skills):**
```
saveContextSnapshot(
  activeSkill: string,
  currentStep: string,
  pendingQuestion?: string,
  inProgressItem?: number,
  recentContext?: Array<{type: string, content: string}>
): void
```

---

### Component Interactions

```
rough-draft (skeleton) 
    |-- generates tests field for each task
    v
executing-plans
    |-- reads tests field from task graph
    |-- passes to subagent-driven-development
    v
subagent-driven-development
    |-- passes test patterns to implementer
    v
implementer (TDD)
    |-- runs only targeted tests during RED-GREEN-REFACTOR
```

```
any skill (brainstorming, rough-draft, executing-plans)
    |-- calls saveContextSnapshot() after key milestones
    v
context-snapshot.json
    ^
    |-- read on resume
collab (resume flow)
    |-- checks for snapshot
    |-- invokes activeSkill from snapshot
```

## Pseudocode

### Item 1: Test Execution Strategy

#### rough-draft/skill.md - Skeleton Phase Addition

```
FUNCTION generateTestPatterns(files):
  testPatterns = []
  FOR each file in files:
    # Extract path components
    dir = dirname(file)
    basename = filename without extension
    ext = file extension (e.g., ".ts", ".js")
    
    # Generate possible test file locations
    pattern1 = "{dir}/{basename}.test{ext}"
    pattern2 = "{dir}/__tests__/{basename}.test{ext}"
    
    ADD pattern1 to testPatterns
    ADD pattern2 to testPatterns
  
  RETURN testPatterns

# In Step 2: Build task dependency graph
FOR each task in tasks:
  task.tests = generateTestPatterns(task.files)
```

#### executing-plans/skill.md - Task Execution Modification

```
# In Step 2: Execute Batch - Dependency-Aware Execution

FUNCTION executeTask(task):
  # Existing: dispatch to subagent-driven-development
  # NEW: pass test patterns in task prompt
  
  taskPrompt = """
    Task ID: {task.id}
    Files: {task.files}
    Description: {task.description}
    
    ## Targeted Tests (run these during TDD)
    Tests: {task.tests}
    
    During RED-GREEN-REFACTOR, run ONLY the tests in the list above.
    Do NOT run the full test suite.
  """
  
  DISPATCH Task agent with taskPrompt

# NEW: After wave completes
FUNCTION onWaveComplete(completedTasks):
  PRINT "Wave complete. Running full test suite..."
  RUN full test suite (e.g., npm test)
  
  IF tests fail:
    PRINT "Full suite failed. Investigate before continuing."
    STOP and report
  ELSE:
    PRINT "Full suite passed. Proceeding to next wave."
```

#### subagent-driven-development/implementer-prompt.md - Addition

```
# Add to implementer prompt template:

## Test Execution
When following TDD (RED-GREEN-REFACTOR):
- Run ONLY these tests: {task.tests}
- Command: npm test -- {task.tests joined by space}
- Do NOT run full test suite until told to
```

---

### Item 2: Collab Compaction Handling

#### collab-compact/skill.md - Full Logic

```
# Step 1: Verify active session
sessions = LIST directories in .collab/
IF sessions is empty:
  PRINT "No active collab session. Use /collab first."
  STOP

IF multiple sessions:
  ASK user which session
session = selected session

# Step 2: Save context snapshot
snapshot = {
  version: 1,
  timestamp: current ISO timestamp,
  activeSkill: determine from collab-state.json phase,
  currentStep: determine from phase (e.g., "CLARIFYING", "interface"),
  pendingQuestion: null,  # Will be filled by calling skill if known
  inProgressItem: read from collab-state.json currentItem,
  recentContext: []  # Minimal - design doc has the real context
}

WRITE snapshot to .collab/{session}/context-snapshot.json

# Step 3: Update collab-state.json
state = READ .collab/{session}/collab-state.json
state.hasSnapshot = true
WRITE state

# Step 4: Trigger compaction
PRINT "Context snapshot saved. Triggering compaction..."
INVOKE /compact command

# Note: After compaction, conversation resumes
# Collab skill will detect snapshot on next /collab invocation
```

#### collab/skill.md - Resume Flow Modification

```
# Replace Step 5: Resume Session

## Step 5: Resume Session (Modified)

### 5.1 Check for context snapshot
snapshotPath = .collab/{session}/context-snapshot.json
IF file exists at snapshotPath:
  snapshot = READ snapshotPath
  
  PRINT "Restoring from context snapshot..."
  PRINT "Active skill: {snapshot.activeSkill}"
  PRINT "Step: {snapshot.currentStep}"
  
  IF snapshot.inProgressItem:
    PRINT "In-progress item: {snapshot.inProgressItem}"
  
  # Clear snapshot (one-time use)
  DELETE snapshotPath
  
  # Update state
  state.hasSnapshot = false
  WRITE state
  
  # Invoke the active skill directly
  INVOKE skill: {snapshot.activeSkill}
  STOP (skill takes over)

### 5.2 No snapshot - route by phase
state = READ .collab/{session}/collab-state.json

IF state.phase starts with "brainstorming":
  # Check for pending work items
  INVOKE ready-to-implement (existing behavior)
  
ELSE IF state.phase starts with "rough-draft":
  INVOKE rough-draft skill
  
ELSE IF state.phase == "implementation":
  INVOKE executing-plans skill
  
ELSE:
  PRINT "Unknown phase: {state.phase}"
  STOP
```

#### Snapshot Saving in Skills

```
# Add to brainstorming/skill.md - after each user answer

FUNCTION saveSnapshot(pendingQuestion):
  session = current session name
  state = READ collab-state.json
  
  snapshot = {
    version: 1,
    timestamp: now(),
    activeSkill: "brainstorming",
    currentStep: current phase (EXPLORING/CLARIFYING/DESIGNING/VALIDATING),
    pendingQuestion: pendingQuestion,
    inProgressItem: state.currentItem,
    recentContext: []
  }
  
  WRITE to .collab/{session}/context-snapshot.json
  
  state.hasSnapshot = true
  WRITE state

# Call saveSnapshot() after:
# - User answers a question
# - Phase transition (EXPLORING → CLARIFYING, etc.)
# - Before invoking another skill
```

```
# Add to rough-draft/skill.md - at phase transitions

FUNCTION saveSnapshot():
  session = current session name
  state = READ collab-state.json
  
  snapshot = {
    version: 1,
    timestamp: now(),
    activeSkill: "rough-draft",
    currentStep: state.phase (e.g., "rough-draft/interface"),
    pendingQuestion: null,
    inProgressItem: null,
    recentContext: []
  }
  
  WRITE to .collab/{session}/context-snapshot.json
  state.hasSnapshot = true
  WRITE state

# Call saveSnapshot() after:
# - User accepts proposed interface/pseudocode/skeleton
# - Before transitioning to next phase
```

```
# Add to executing-plans/skill.md - after task completions

FUNCTION saveSnapshot():
  session = current session name
  state = READ collab-state.json
  
  snapshot = {
    version: 1,
    timestamp: now(),
    activeSkill: "executing-plans",
    currentStep: "implementation",
    pendingQuestion: null,
    inProgressItem: null,
    recentContext: [
      { type: "progress", content: "Completed tasks: {list}" }
    ]
  }
  
  WRITE to .collab/{session}/context-snapshot.json
  state.hasSnapshot = true
  WRITE state

# Call saveSnapshot() after:
# - Each wave completes
# - Before asking for user feedback
```

## Skeleton

### Planned Files

**Note:** These are skill markdown files (instructions for Claude), not source code files.

- [ ] `skills/collab-compact/skill.md` - NEW: Manual compaction skill
- [ ] `skills/collab/skill.md` - MODIFY: Resume flow with snapshot check
- [ ] `skills/brainstorming/skill.md` - MODIFY: Add snapshot saving
- [ ] `skills/rough-draft/skill.md` - MODIFY: Add tests field generation + snapshot saving
- [ ] `skills/executing-plans/skill.md` - MODIFY: Targeted tests + wave checkpoint + snapshot saving
- [ ] `skills/subagent-driven-development/implementer-prompt.md` - MODIFY: Pass test patterns

### Planned File Contents

#### NEW: skills/collab-compact/skill.md

```markdown
---
name: collab-compact
description: Save context and trigger compaction for clean resume
user-invocable: true
---

# Collab Compact

Save current collab session context and trigger compaction for a clean context resume.

## When to Use

- Context is getting large and compaction is approaching
- Before a long break in the session
- Proactively to ensure clean state

## Process

### Step 1: Verify Active Session

\`\`\`bash
ls -d .collab/*/ 2>/dev/null | xargs -I{} basename {}
\`\`\`

If no sessions: "No active collab session. Use /collab first." STOP.
If multiple sessions: Ask user which session.

### Step 2: Save Context Snapshot

Read current state from `.collab/<session>/collab-state.json`.

Determine activeSkill from phase:
- "brainstorming" → activeSkill = "brainstorming"
- "rough-draft/*" → activeSkill = "rough-draft"
- "implementation" → activeSkill = "executing-plans"

Write snapshot to `.collab/<session>/context-snapshot.json`:

\`\`\`json
{
  "version": 1,
  "timestamp": "<current-ISO-timestamp>",
  "activeSkill": "<determined-skill>",
  "currentStep": "<phase-from-state>",
  "pendingQuestion": null,
  "inProgressItem": <currentItem-from-state>,
  "recentContext": []
}
\`\`\`

### Step 3: Update State

Update `.collab/<session>/collab-state.json`:
- Set `hasSnapshot: true`

### Step 4: Trigger Compaction

\`\`\`
Context snapshot saved to .collab/<session>/context-snapshot.json

Triggering compaction now...
\`\`\`

Invoke the /compact command.

### Step 5: Resume Instructions

After compaction, the conversation resumes. Instruct user:

\`\`\`
Compaction complete. Run /collab to resume your session.
The snapshot will restore your context automatically.
\`\`\`
```

---

#### MODIFY: skills/collab/skill.md - Step 5 Addition

Add before existing Step 5 content:

```markdown
### 5.1 Check for Context Snapshot

\`\`\`bash
test -f .collab/<session>/context-snapshot.json && echo "snapshot exists" || echo "no snapshot"
\`\`\`

**If snapshot exists:**

1. Read snapshot:
   \`\`\`bash
   cat .collab/<session>/context-snapshot.json
   \`\`\`

2. Display restoration message:
   \`\`\`
   Restoring from context snapshot...
   Active skill: <activeSkill>
   Step: <currentStep>
   \`\`\`

3. Delete snapshot (one-time use):
   \`\`\`bash
   rm .collab/<session>/context-snapshot.json
   \`\`\`

4. Update state:
   - Set `hasSnapshot: false` in collab-state.json

5. Invoke the active skill directly:
   - If activeSkill == "brainstorming" → Invoke brainstorming skill
   - If activeSkill == "rough-draft" → Invoke rough-draft skill
   - If activeSkill == "executing-plans" → Invoke executing-plans skill

**STOP** - skill takes over from here.

**If no snapshot:** Continue to 5.2 (existing resume behavior, route by phase)
```

---

#### MODIFY: skills/rough-draft/skill.md - Skeleton Phase Addition

Add to Phase 3: Skeleton, Step 2:

```markdown
**Step 2.5: Generate Test Patterns**

For each task in the dependency graph, generate the `tests` field:

For each file in task.files:
1. Extract directory: `dir = dirname(file)`
2. Extract basename: `name = filename without extension`
3. Extract extension: `ext = file extension`
4. Generate patterns:
   - `{dir}/{name}.test{ext}`
   - `{dir}/__tests__/{name}.test{ext}`

Add to task YAML:

\`\`\`yaml
tasks:
  - id: example-task
    files: [src/auth/service.ts]
    tests: [src/auth/service.test.ts, src/auth/__tests__/service.test.ts]  # AUTO-GENERATED
    description: ...
\`\`\`
```

---

#### MODIFY: skills/executing-plans/skill.md - Targeted Tests Addition

Add to Step 2: Execute Batch:

```markdown
### Task Prompt with Test Patterns

When dispatching tasks, include the `tests` field in the prompt:

\`\`\`
## Targeted Tests

During TDD (RED-GREEN-REFACTOR), run ONLY these tests:
{task.tests}

Command: npm test -- {tests joined by space}

Do NOT run the full test suite during TDD cycles.
\`\`\`

### Wave Completion Checkpoint

After all tasks in a wave complete:

1. Run full test suite:
   \`\`\`bash
   npm test
   \`\`\`

2. If tests fail:
   \`\`\`
   Full test suite failed after wave completion.
   Investigate failures before proceeding to next wave.
   \`\`\`
   STOP and report.

3. If tests pass:
   \`\`\`
   Full test suite passed. Proceeding to next wave.
   \`\`\`
```

---

### Task Dependency Graph

```yaml
tasks:
  - id: collab-compact-skill
    files: [skills/collab-compact/skill.md]
    tests: []  # No tests for skill files
    description: Create new collab-compact skill
    parallel: true

  - id: collab-resume-modification
    files: [skills/collab/skill.md]
    tests: []
    description: Add snapshot check to resume flow
    parallel: true

  - id: rough-draft-tests-field
    files: [skills/rough-draft/skill.md]
    tests: []
    description: Add tests field generation to skeleton phase
    parallel: true

  - id: executing-plans-targeted-tests
    files: [skills/executing-plans/skill.md]
    tests: []
    description: Add targeted test execution and wave checkpoints
    depends-on: [rough-draft-tests-field]

  - id: implementer-prompt-tests
    files: [skills/subagent-driven-development/implementer-prompt.md]
    tests: []
    description: Add test pattern instructions to implementer
    depends-on: [executing-plans-targeted-tests]

  - id: brainstorming-snapshot
    files: [skills/brainstorming/skill.md]
    tests: []
    description: Add snapshot saving to brainstorming
    depends-on: [collab-compact-skill]

  - id: rough-draft-snapshot
    files: [skills/rough-draft/skill.md]
    tests: []
    description: Add snapshot saving to rough-draft
    depends-on: [collab-compact-skill, rough-draft-tests-field]

  - id: executing-plans-snapshot
    files: [skills/executing-plans/skill.md]
    tests: []
    description: Add snapshot saving to executing-plans
    depends-on: [collab-compact-skill, executing-plans-targeted-tests]
```

## Diagrams
(auto-synced)